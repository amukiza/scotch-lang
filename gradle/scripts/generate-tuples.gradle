def tuplesPath = project.file("${projectDir}/src/generated/tuples")

task generateTuples (type: GenerateTuples) {
    sourcePath tuplesPath
    count 24
}

task cleanTuples (type: Delete) {
    delete tuplesPath
}

project.sourceSets.main.java.srcDir tuplesPath
compileJava.dependsOn << generateTuples
clean.dependsOn << cleanTuples

class GenerateTuples extends DefaultTask {

    def generated = "@Generated(value = \"${project.group}:${project.name}:${project.version}:/gradle/scripts/generate-tuples.groovy\", date = \"${new Date()}\")"
    def sourcePath
    def packagePath
    def tupleRange

    def setSourcePath(sourcePath) {
        this.sourcePath = sourcePath
        this.packagePath = new File(sourcePath, "scotch/data/tuple")
    }

    def setCount(count) {
        this.tupleRange = (1..count - 1)
    }

    def setUp() {
        packagePath.deleteDir()
        packagePath.mkdirs()
    }

    @TaskAction
    def run() {
        setUp()
        generateTupleValues()
        generateTupleConstructors()
    }

    def generateTupleConstructors() {
        def tupleFiles = tupleRange.collect {
            new File(packagePath, "Tuple${it + 1}.java")
        }

        tupleRange.each {
            def size = it + 1;
            def range = (0..it)
            def content = [
                'package scotch.data.tuple;',
                '',
                'import java.util.Objects;',
                'import javax.annotation.Generated;',
                '',
            ]

            content << generated
            content << "public final class Tuple${size}<${range.collect { t -> "T${t}" }.join(', ')}> {"

            content << ''
            range.each { t ->
                content << "    private final T${t} _${t};"
            }

            content << ''
            content << "    public Tuple${size}(${range.collect { t -> "T${t} _${t}" }.join(', ')}) {"
            range.each { t ->
                content << "        this._${t} = _${t};"
            }
            content << "    }"

            content << ''
            content << '    @Override'
            content << '    public boolean equals(Object o) {'
            content << '        if (o == this) {'
            content << '            return true;'
            content << "        } else if (o instanceof Tuple${size}) {"
            content << "            Tuple${size} other = (Tuple${size}) o;"
            content << "            return ${range.collect { t -> "Objects.equals(_${t}, other._${t})"}.join("\n                && ")};"
            content << '        } else {'
            content << '            return false;'
            content << '        }'
            content << '    }'

            range.each { t ->
                content << ''
                content << "    public T${t} get_${t}() {"
                content << "        return _${t};"
                content << "    }"
            }

            content << ''
            content << '    @Override'
            content << '    public int hashCode() {'
            content << "        return Objects.hash(${range.collect { t -> "_${t}" }.join(', ')});"
            content << "    }"
            content << ''

            content << "    public <U> U into(Deconstruct${size}<U, ${range.collect { t -> "T${t}" }.join(', ')}> deconstructor) {"
            content << "        return deconstructor.apply(${range.collect { t -> "_${t}" }.join(', ')});"
            content << '    }'
            content << ''

            content << '    @Override'
            content << '    public String toString() {'
            content << "        return \"(\" + ${range.collect { t -> "_${t} + " }.join(' ", " + ')} \")\";"
            content << '    }'
            content << ''

            content << '    @FunctionalInterface'
            content << "    public interface Deconstruct${size}<U, ${range.collect { t -> "T${t}" }.join(", ")}> {"
            content << ''
            content << "        U apply(${range.collect { t -> "T${t} _${t}" }.join(', ')});"
            content << '    }'
            content << '}'
            content << ''

            tupleFiles.get(it - 1).delete()
            tupleFiles.get(it - 1).write(content.join('\n'))
        }
    }

    def generateTupleValues() {
        def util = [
            'package scotch.data.tuple;',
            '',
            'import java.util.function.Function;',
            'import javax.annotation.Generated;',
            '',
            generated,
            '@SuppressWarnings({ "unused", "unchecked" })',
            'public final class TupleValues {',
        ]

        tupleRange.each {
            def size = it + 1
            def range = (0..it)
            def generics = "<${range.collect { t -> "T${t}" }.join(', ')}>"

            util << ''
            util << "    public static ${generics} Tuple${size}${generics} tuple${size}(${range.collect { t -> "T${t} _${t}" }.join(", ")}) {"
            util << "        return new Tuple${size}<>(${range.collect { t -> "_${t}" }.join(', ')});"
            util << '    }'
        }

        util << ''
        util << '    private TupleValues() {'
        util << '        // intentionally empty'
        util << '    }'
        util << '}'
        util << ''

        def utilFile = new File(packagePath, "TupleValues.java")
        utilFile.write(util.join('\n'))
    }
}
